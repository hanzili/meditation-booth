package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/hanzili/oniji-go-server/config"
	"github.com/hanzili/oniji-go-server/constants"
	"github.com/hanzili/oniji-go-server/graph/model"
	"github.com/hanzili/oniji-go-server/models"
	"github.com/hanzili/oniji-go-server/repositories"
	"github.com/hanzili/oniji-go-server/utils"
	log "github.com/sirupsen/logrus"
)

// OnijiCreateSession is the resolver for the ONIJI_CreateSession field.
func (r *mutationResolver) OnijiCreateSession(ctx context.Context, input model.OnijiCreateSessionInput) (*model.OnijiSessionReponse, error) {
	userId := ctx.Value(constants.CtxKeyUserId).(string)

	session := &models.Session{
		Mood:        models.Mood(input.Mood),
		SessionType: models.SessionType(input.SessionType),
		HasScent:    input.HasScent,
		UserId:      uuid.MustParse(userId),
	}
	// find the mapping for the session
	musicInfo := utils.MusicInfo{
		Mood:        utils.Mood(input.Mood),
		SessionType: models.SessionType(input.SessionType),
		Language:    input.Language,
		IsLong:      input.IsLong,
	}
	session.Music = utils.GetMusicForSession(musicInfo)

	// get current time
	timeNow := time.Now()
	session.StartTime = &timeNow
	err := repositories.SessionRepo.Create(session)
	if err != nil {
		return nil, err
	}

	// start the session
	// start detecting brave wave
	// start defusing the scent
	// start the music
	// Send HTTP request to booth server
	sessionId := session.Id.String()
	musicName := session.Music.Name
	boothServerURL := fmt.Sprintf("%s/start-session/%s/%s", config.GetConfig().BoothUrl, sessionId, musicName)
	resp, err := http.Get(boothServerURL)
	if err != nil {
		log.WithFields(log.Fields{
			"error": err.Error(),
		}).Error("failed to start session on booth server")
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to start session on booth server, status code: %d", resp.StatusCode)
	}

	return &model.OnijiSessionReponse{
		Session: convertToGqlSession(session),
	}, nil
}

// OnijiEndSession is the resolver for the ONIJI_EndSession field.
func (r *mutationResolver) OnijiEndSession(ctx context.Context, input model.OnijiEndSessionInput) (*model.OnijiSessionReponse, error) {
	userId := ctx.Value(constants.CtxKeyUserId).(string)

	session, err := repositories.SessionRepo.GetById(input.ID)
	if err != nil {
		return nil, err
	}

	if userId != session.UserId.String() {
		errorCode := 401
		errorMsg := "You can only end session of your own"
		return &model.OnijiSessionReponse{
			ErrorCode:    &errorCode,
			ErrorMessage: &errorMsg,
			Session:      nil,
		}, nil
	}

	// stop detecting brave wave
	// stop defusing the scent
	// stop the music
	sessionId := session.Id.String()
	boothServerURL := fmt.Sprintf("%s/end-session/%s", config.GetConfig().BoothUrl, sessionId)
	resp, err := http.Get(boothServerURL)
	if err != nil {
		log.WithFields(log.Fields{
			"sessionId": sessionId,
			"response":  resp,
			"error":     err.Error(),
		}).Error("failed to end session on booth server")
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.WithFields(log.Fields{
			"sessionId": sessionId,
			"response":  resp,
		}).Error("failed to end session on booth server")
		return nil, fmt.Errorf("failed to end session on booth server, status code: %d", resp.StatusCode)
	}

	timeNow := time.Now()
	session.EndTime = &timeNow
	err = repositories.SessionRepo.Update(session)
	if err != nil {
		return nil, err
	}

	return &model.OnijiSessionReponse{
		Session: convertToGqlSession(session),
	}, nil
}

// OnijiUpdateSession is the resolver for the ONIJI_UpdateSession field.
func (r *mutationResolver) OnijiUpdateSession(ctx context.Context, input model.OnijiUpdateSessionInput) (*model.OnijiSessionReponse, error) {
	userId := ctx.Value(constants.CtxKeyUserId).(string)

	session, err := repositories.SessionRepo.GetById(input.ID)
	if err != nil {
		return nil, err
	}

	if userId != session.UserId.String() {
		errorCode := 401
		errorMsg := "You can only update session of your own"
		return &model.OnijiSessionReponse{
			ErrorCode:    &errorCode,
			ErrorMessage: &errorMsg,
			Session:      nil,
		}, nil
	}

	session.Survey = input.Survey
	err = repositories.SessionRepo.Update(session)
	if err != nil {
		return nil, err
	}

	return &model.OnijiSessionReponse{
		Session: convertToGqlSession(session),
	}, nil
}

// OnijiGetSessions is the resolver for the ONIJI_GetSessions field.
func (r *queryResolver) OnijiGetSessions(ctx context.Context) (*model.OnijiSessionsResponse, error) {
	userId := ctx.Value(constants.CtxKeyUserId).(string)
	sessions, err := repositories.SessionRepo.GetAllSessionByUserId(uuid.MustParse(userId))
	if err != nil {
		return nil, err
	}

	return &model.OnijiSessionsResponse{
		Sessions:   convertToGqlSessions(sessions),
		TotalCount: len(sessions), //TODO: return total count
	}, nil
}

// OnijiGetSession is the resolver for the ONIJI_GetSession field.
func (r *queryResolver) OnijiGetSession(ctx context.Context, input model.OnijiGetSessionInput) (*model.OnijiSessionReponse, error) {
	// check if the user is the owner of the session
	userId := ctx.Value(constants.CtxKeyUserId).(string)

	session, err := repositories.SessionRepo.GetById(input.ID)
	if err != nil {
		return nil, err
	}

	if userId != session.UserId.String() {
		errorCode := 401
		errorMsg := "You can only get session of your own"
		return &model.OnijiSessionReponse{
			ErrorCode:    &errorCode,
			ErrorMessage: &errorMsg,
			Session:      nil,
		}, nil
	}

	return &model.OnijiSessionReponse{Session: convertToGqlSession(session)}, nil
}
