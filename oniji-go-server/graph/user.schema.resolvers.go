package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"github.com/hanzili/oniji-go-server/config"
	"github.com/hanzili/oniji-go-server/constants"
	"github.com/hanzili/oniji-go-server/graph/model"
	"github.com/hanzili/oniji-go-server/models"
	"github.com/hanzili/oniji-go-server/repositories"
	"github.com/hanzili/oniji-go-server/utils"
	"github.com/supabase-community/gotrue-go/types"
	supabase "github.com/supabase-community/supabase-go"
)

// OnijiSignupByEmail is the resolver for the ONIJI_SignupByEmail field.
func (r *mutationResolver) OnijiSignupByEmail(ctx context.Context, input model.OnijiSignupByEmailInput) (*model.OnijiUserReponse, error) {
	sConfig := config.GetConfig().SupabaseConfig
	client, err := supabase.NewClient(sConfig.Url, sConfig.AnonKey, nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Auth.Signup(types.SignupRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	user := &models.User{
		Id:        res.User.ID,
		Email:     input.Email,
		Password:  input.Password,
		FirstName: &input.FirstName,
		LastName:  &input.LastName,
	}
	err = repositories.UserRepo.Create(user)
	if err != nil {
		return nil, err
	}

	gqlUser := convertToGqlUser(user)
	gqlUser.Token = res.AccessToken
	gqlUser.RefreshToken = res.RefreshToken

	return &model.OnijiUserReponse{
		User: gqlUser,
	}, nil
}

// OnijiLoginByEmail is the resolver for the ONIJI_LoginByEmail field.
func (r *mutationResolver) OnijiLoginByEmail(ctx context.Context, input model.OnijiLoginByEmailInput) (*model.OnijiUserReponse, error) {
	sConfig := config.GetConfig().SupabaseConfig
	client, err := supabase.NewClient(sConfig.Url, sConfig.AnonKey, nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Auth.SignInWithEmailPassword(input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	user, err := repositories.UserRepo.GetByEmail(input.Email)
	if err != nil {
		return nil, err
	}

	gqlUser := convertToGqlUser(user)
	gqlUser.Token = res.AccessToken
	gqlUser.RefreshToken = res.RefreshToken

	return &model.OnijiUserReponse{
		User: gqlUser,
	}, nil
}

// OnijiRefreshToken is the resolver for the ONIJI_RefreshToken field.
func (r *mutationResolver) OnijiRefreshToken(ctx context.Context, input model.OnijiRefreshTokenInput) (*model.OnijiUserReponse, error) {
	sConfig := config.GetConfig().SupabaseConfig
	client, err := supabase.NewClient(sConfig.Url, sConfig.AnonKey, nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Auth.RefreshToken(input.RefreshToken)
	if err != nil {
		return nil, err
	}

	user, err := repositories.UserRepo.GetById(res.Session.User.ID.String())
	if err != nil {
		return nil, err
	}

	gqlUser := convertToGqlUser(user)
	gqlUser.Token = res.AccessToken
	gqlUser.RefreshToken = res.RefreshToken

	return &model.OnijiUserReponse{
		User: gqlUser,
	}, nil
}

// OnijiResetPassword is the resolver for the ONIJI_ResetPassword field.
func (r *mutationResolver) OnijiResetPassword(ctx context.Context, input model.OnijiResetPasswordInput) (*model.OnijiUserReponse, error) {
	err := utils.Recover(input.Email, "http://localhost:3000/reset")
	if err != nil {
		return nil, err
	}

	return &model.OnijiUserReponse{}, nil
}

// OnijiSignOut is the resolver for the ONIJI_SignOut field.
func (r *mutationResolver) OnijiSignOut(ctx context.Context) (*model.OnijiUserReponse, error) {
	sConfig := config.GetConfig().SupabaseConfig
	client, err := supabase.NewClient(sConfig.Url, sConfig.AnonKey, nil)
	session := types.Session{}
	session.AccessToken = ctx.Value(constants.CtxKeyAuthorization).(string)
	client.UpdateAuthSession(session)
	if err != nil {
		return nil, err
	}

	err = client.Auth.Logout()
	if err != nil {
		return nil, err
	}

	return &model.OnijiUserReponse{}, nil
}

// OnijiUpdateUser is the resolver for the ONIJI_UpdateUser field.
func (r *mutationResolver) OnijiUpdateUser(ctx context.Context, input model.OnijiUpdateUserInput) (*model.OnijiUserReponse, error) {
	// get the user from db
	user, err := repositories.UserRepo.GetById(ctx.Value(constants.CtxKeyUserId).(string))
	if err != nil {
		return nil, err
	}

	// if password change, need to change that on supabase
	var newAccessToken string
	var newRefreshToken string
	if input.Password != nil {
		sConfig := config.GetConfig().SupabaseConfig
		client, err := supabase.NewClient(sConfig.Url, sConfig.AnonKey, nil)
		session := types.Session{}
		session.AccessToken = ctx.Value(constants.CtxKeyAuthorization).(string)
		client.UpdateAuthSession(session)
		if err != nil {
			return nil, err
		}

		_, err = client.Auth.UpdateUser(types.UpdateUserRequest{
			Password: input.Password,
		})
		if err != nil {
			return nil, err
		}

		// logout the user to disable the old access token and refresh token
		err = client.Auth.Logout()
		if err != nil {
			return nil, err
		}

		// with the new password, authenticate the user to get new token
		res, err := client.Auth.SignInWithEmailPassword(user.Email, *input.Password)
		if err != nil {
			return nil, err
		}

		newAccessToken = res.AccessToken
		newRefreshToken = res.RefreshToken
	}

	// update user on db
	if input.FirstName != nil {
		user.FirstName = input.FirstName
	}
	if input.LastName != nil {
		user.LastName = input.LastName
	}
	if input.Language != nil {
		user.Language = (*models.Language)(input.Language)
	}
	if input.Password != nil {
		user.Password = *input.Password
	}
	if input.Survey != nil {
		user.Survey = input.Survey
	}

	err = repositories.UserRepo.Update(user)
	if err != nil {
		return nil, err
	}

	gqlUser := convertToGqlUser(user)

	if input.Password != nil {
		gqlUser.Token = newAccessToken
		gqlUser.RefreshToken = newRefreshToken
	}

	return &model.OnijiUserReponse{
		User: gqlUser,
	}, nil
}

// OnijiUser is the resolver for the ONIJI_User field.
func (r *queryResolver) OnijiUser(ctx context.Context) (*model.OnijiUserReponse, error) {
	user, err := repositories.UserRepo.GetById(ctx.Value(constants.CtxKeyUserId).(string))
	if err != nil {
		return nil, err
	}

	gqlUser := convertToGqlUser(user)

	return &model.OnijiUserReponse{
		User: gqlUser,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
